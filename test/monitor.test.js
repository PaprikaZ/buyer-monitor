// Generated by CoffeeScript 1.8.0
var config, fs, monitor, rewire, verdicts;

fs = require('fs');

config = require('../lib/config.js');

rewire = require('rewire');

verdicts = require('./cache/builder.js').generateVerdicts();

monitor = rewire('../lib/monitor.js');

describe('monitor module', function() {
  var createMonitor;
  config.accounts = [
    {
      accessToken: 'testtoken0000'
    }, {
      accessToken: 'testtoken0001'
    }, {
      accessToken: 'testtoken0002'
    }
  ];
  monitor.__set__({
    logger: {
      debug: function() {},
      warn: function() {},
      info: function() {},
      error: function() {}
    },
    config: config,
    fs: {
      readFileSync: function() {
        return JSON.stringify(verdicts);
      }
    },
    db: {
      getClient: function() {
        return {
          rpop: function() {}
        };
      }
    }
  });
  createMonitor = monitor.createMonitor;
  describe('create monitor', function() {
    it('should throw access token empty error when no token found', function() {
      var revert;
      revert = monitor.__set__({
        config: {
          accounts: []
        }
      });
      createMonitor.should["throw"]('access tokens empty');
      revert();
    });
    it('should throw verdicts empty error when no verdicts found', function() {
      var revert;
      revert = monitor.__set__({
        fs: {
          readFileSync: function() {
            return JSON.stringify([]);
          }
        }
      });
      createMonitor.should["throw"]('products empty');
      revert();
    });
  });
  describe('verify user tokens', function() {
    it('should start monitoring when all verifications done', function() {
      var called, counter, m, revert;
      counter = 0;
      called = false;
      revert = monitor.__set__({
        request: {
          get: function(options, callback) {
            counter = counter + 1;
            callback(null, {
              statusCode: 200,
              url: 'www.example.com'
            }, 'test');
          }
        }
      });
      m = createMonitor();
      m.startMonitoring = function() {
        called = true;
        counter.should.equal(config.accounts.length);
      };
      m.start();
      called.should.be["true"];
      revert();
    });
    it('should throw error when all tokens are invalid', function() {
      var m, revert;
      revert = monitor.__set__({
        request: {
          get: function(options, callback) {
            callback(new Error('test mock error'));
          }
        }
      });
      m = createMonitor();
      m.startMonitoring = function() {};
      m.start.bind(m).should["throw"]('all access token is invalid');
      revert();
    });
    it('should drop invalid tokens when all verifications done', function() {
      var m, revert;
      revert = monitor.__set__({
        request: {
          get: function(options, callback) {
            if (options.auth.user === 'testtoken0001') {
              callback(new Error('test mock error'));
            } else {
              callback(null, {
                statusCode: 200,
                url: 'www.example.com'
              }, 'test');
            }
          }
        }
      });
      m = createMonitor();
      m.startMonitoring = function() {};
      m.start();
      m.accessTokens.should.eql(['testtoken0000', 'testtoken0002']);
      revert();
    });
  });
  describe('monitoring', function() {
    var makeRpop, revert;
    makeRpop = function(queue) {
      return function(key, callback) {
        if (0 < queue.length) {
          return callback(null, queue.pop());
        } else {
          return callback(null, null);
        }
      };
    };
    revert = null;
    beforeEach(function() {
      revert = monitor.__set__({
        request: {
          get: function(options, callback) {
            callback(null, {
              statusCode: 200,
              url: 'www.example.com'
            }, 'test body');
          }
        },
        setInterval: function() {},
        setTimeout: function() {}
      });
    });
    after(function() {
      revert();
    });
    it('should call send requests when push queue clearing done', function() {
      var m, queue, v;
      v = verdicts.slice().pop();
      queue = [
        JSON.stringify({
          id: v.id,
          site: v.site
        })
      ];
      revert = monitor.__set__({
        db: {
          getClient: function() {
            return {
              rpop: makeRpop(queue)
            };
          }
        }
      });
      m = createMonitor();
      m.sendRequests = function() {};
      m.start();
      queue.should.be.empty;
      revert();
    });
    it('should bypass database pop error', function() {
      var m;
      revert = monitor.__set__({
        db: {
          getClient: function() {
            return {
              rpop: function(key, callback) {
                callback(new Error('test mock error'));
              }
            };
          }
        }
      });
      m = createMonitor();
      m.start.bind(m).should["throw"]('test mock error');
      revert();
    });
    it('should do nothing when all seeds is delayed', function() {
      var called, queue;
      queue = verdicts.map(function(v) {
        return {
          id: v.id,
          site: v.site
        };
      }).map(function(v) {
        return JSON.stringify(v);
      });
      called = false;
      revert = monitor.__set__({
        db: {
          getClient: function() {
            return {
              rpop: makeRpop(queue)
            };
          }
        },
        createVisitor: function() {
          called = true;
          return {
            visit: function() {}
          };
        }
      });
      createMonitor().start();
      called.should.be["false"];
      revert();
    });
    it('should push back delayed seeds when timeout', function() {
      var called, m, queue, remainingSeeds, seeds, v;
      called = false;
      v = verdicts.slice().pop();
      queue = [
        JSON.stringify({
          id: v.id,
          site: v.site
        })
      ];
      seeds = verdicts.slice();
      remainingSeeds = seeds.slice(0, seeds.length - 1);
      m = null;
      revert = monitor.__set__({
        db: {
          getClient: function() {
            return {
              rpop: makeRpop(queue)
            };
          }
        },
        setTimeout: function(callback, timeout) {
          called = true;
          m.seeds.map(function(seed) {
            return {
              id: seed.id,
              site: seed.site
            };
          }).should.eql(remainingSeeds.map(function(verdict) {
            return {
              id: verdict.id,
              site: verdict.site
            };
          }));
          callback();
          m.seeds.map(function(seed) {
            return {
              id: seed.id,
              site: seed.site
            };
          }).should.eql(seeds.map(function(verdict) {
            return {
              id: verdict.id,
              site: verdict.site
            };
          }));
        }
      });
      m = createMonitor();
      m.sendRequests = function() {};
      m.start();
      called.should.be["true"];
      revert();
    });
  });
});
