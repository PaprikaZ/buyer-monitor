// Generated by CoffeeScript 1.8.0
var build, clean, crypto, digestEncoding, fs, hashAlgorithm, help, main, parsedProductsData, path, products, request;

fs = require('fs');

path = require('path');

crypto = require('crypto');

request = require('request');

parsedProductsData = JSON.parse(fs.readFileSync(path.join(__dirname, './product.json')));

hashAlgorithm = parsedProductsData.hashAlgorithm;

digestEncoding = parsedProductsData.digestEncoding;

products = parsedProductsData.products;

clean = function() {
  var htmlFiles;
  htmlFiles = fs.readdirSync(__dirname).filter(function(filename) {
    return /.*\.html$/.test(filename);
  });
  htmlFiles.map(function(filename) {
    fs.unlink(path.join(__dirname, filename));
  });
};

build = function() {
  var makeRequestCallback, req, requestCallback;
  clean();
  makeRequestCallback = function() {
    var afterCallbacksDone, callback, counter, urlToHtmlTable;
    urlToHtmlTable = {};
    counter = products.length;
    afterCallbacksDone = function() {
      fs.writeFileSync(path.join(__dirname, './cache.json'), JSON.stringify(urlToHtmlTable));
    };
    callback = function(err, res, body, url) {
      var fileName, md5sum;
      if (!err && res.statusCode === 200) {
        md5sum = crypto.createHash(hashAlgorithm);
        fileName = md5sum.update(url).digest(digestEncoding) + '.html';
        fs.writeFileSync(path.join(__dirname, fileName), body);
        urlToHtmlTable[url] = fileName;
      } else if (err) {
        throw err;
      } else {
        console.error('response caught error:');
        console.error('url: %s', res.url);
        console.error('status code: %s', res.statusCode);
      }
    };
    return function(err, res, body, url) {
      callback(err, res, body, url);
      counter = counter - 1;
      if (counter === 0) {
        afterCallbacksDone();
      }
    };
  };
  requestCallback = makeRequestCallback();
  req = function(url, callback) {
    return request(url, function(err, res, body) {
      return callback(err, res, body, url);
    });
  };
  products.map(function(item) {
    return item.url;
  }).map(function(url) {
    req(url, requestCallback);
  });
};

help = function() {
  console.log('Help:');
  console.log('> node builder.js build');
  console.log('clean and build new cached pages from product.json');
  console.log('');
  console.log('> node builder.js clean');
  console.log('clean already cached page files *.html');
  console.log('');
  console.log('> node builder.js help');
  console.log('print this help message');
};

main = function() {
  var argv;
  argv = process.argv.slice(2);
  if (argv.length === 1) {
    switch (argv[0]) {
      case 'build':
        build();
        break;
      case 'clean':
        clean();
        break;
      case 'help':
        help();
        break;
      default:
        console.error('error: unknown command');
        help();
    }
  } else {
    console.error('error: unknown commands');
    help();
  }
};

if (require.main === module) {
  main();
}
