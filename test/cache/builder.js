// Generated by CoffeeScript 1.8.0
var build, cacheItemToProduct, cacheItemToVerdict, clean, cleanAndBuild, config, configFile, crypto, digestEncoding, fs, hashAlgorithm, help, htmlDirectory, htmlTableFile, iconv, main, mkdirp, path, request, seed, site;

fs = require('fs');

path = require('path');

crypto = require('crypto');

request = require('request');

mkdirp = require('mkdirp');

iconv = require('iconv-lite');

seed = require('../../lib/seed.js');

site = require('../../lib/site.js');

htmlTableFile = path.join(__dirname, './html.json');

configFile = path.join(__dirname, './config.json');

config = JSON.parse(fs.readFileSync(configFile));

htmlDirectory = path.join(__dirname, config.htmlDirectory);

hashAlgorithm = config.hashAlgorithm;

digestEncoding = config.digestEncoding;

cacheItemToProduct = function(item) {
  var mountField, product;
  product = {};
  mountField = function(field) {
    product[field] = item[field];
  };
  seed.MANDATORY_BASE_FIELDS.map(mountField);
  config.extraFields.map(mountField);
  product.url = site.generateProductUrl(product.id, product.site);
  return product;
};

cacheItemToVerdict = function(item) {
  var verdict;
  verdict = {};
  seed.MANDATORY_BASE_FIELDS.map(function(field) {
    verdict[field] = item[field];
  });
  seed.AVAILABLE_VERDICT_FIELDS.map(function(field) {
    if (item[field]) {
      verdict[field] = item[field];
    }
  });
  return verdict;
};

clean = function() {
  var err, htmlFiles;
  mkdirp.sync(htmlDirectory, '0774');
  htmlFiles = fs.readdirSync(htmlDirectory).filter(function(filename) {
    return /\.html$/.test(filename);
  });
  htmlFiles.map(function(filename) {
    fs.unlinkSync(path.join(htmlDirectory, filename));
  });
  try {
    fs.unlinkSync(htmlTableFile);
  } catch (_error) {
    err = _error;
    if (!(err.errno === 34 && err.code === 'ENOENT')) {
      throw err;
    }
  } finally {
    console.log('clean done.');
  }
};

build = function() {
  var makeRequestCallback, products, requestCallback, requestWrapper;
  products = config.items.map(cacheItemToProduct);
  makeRequestCallback = function() {
    var afterCallbacksDone, callback, counter, urlToHtmlTable;
    urlToHtmlTable = {};
    afterCallbacksDone = function() {
      console.log('build done.');
      fs.writeFileSync(htmlTableFile, JSON.stringify(urlToHtmlTable));
    };
    callback = function(err, res, body, url) {
      var encoding, fileName, filePath, md5sum;
      if (!err && res.statusCode === 200) {
        md5sum = crypto.createHash(hashAlgorithm);
        fileName = md5sum.update(url).digest(digestEncoding) + '.html';
        filePath = path.join(htmlDirectory, fileName);
        encoding = site.getSiteEncoding(site.urlToSite(url));
        fs.writeFileSync(filePath, iconv.decode(new Buffer(body), encoding));
        urlToHtmlTable[url] = filePath;
      } else if (err) {
        console.error('build html cache caught error');
        console.error('msg: %s', err.message);
        throw err;
      } else {
        console.error('response caught error');
        console.error('url: %s', res.url);
        console.error('status code: %s', res.statusCode);
      }
    };
    counter = products.length;
    return function(err, res, body, url) {
      callback(err, res, body, url);
      counter = counter - 1;
      if (counter === 0) {
        afterCallbacksDone();
      }
    };
  };
  requestCallback = makeRequestCallback();
  requestWrapper = function(url, callback) {
    return request.get({
      url: url,
      encoding: null
    }, function(err, res, body) {
      return callback(err, res, body, url);
    });
  };
  products.map(function(item) {
    return item.url;
  }).map(function(url) {
    requestWrapper(url, requestCallback);
  });
};

cleanAndBuild = function() {
  clean();
  build();
};

help = function() {
  console.log('Help:');
  console.log('');
  console.log('> node builder.js build');
  console.log('clean and build new cached pages from product.json');
  console.log('');
  console.log('> node builder.js clean');
  console.log('clean already cached page files');
  console.log('');
  console.log('> node builder.js help');
  console.log('print this help message');
};

main = function() {
  var argv;
  argv = process.argv.slice(2);
  if (argv.length === 1) {
    switch (argv[0]) {
      case 'build':
        cleanAndBuild();
        break;
      case 'clean':
        clean();
        break;
      case 'help':
        help();
        break;
      default:
        console.error('error: unknown command');
        help();
    }
  } else {
    console.error('error: unknown commands');
    help();
  }
};

exports.generateVerdicts = function() {
  return config.items.map(cacheItemToVerdict);
};

module.exports = exports;

if (require.main === module) {
  main();
}
