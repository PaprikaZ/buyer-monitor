// Generated by CoffeeScript 1.8.0
var AVAILABLE_COMPARES, AVAILABLE_VERDICT_FIELDS, MANDATORY_BASE_FIELDS, MANDATORY_EXPAND_FIELDS, Seed, config, expand, field, illegalTypeHandler, noneVerdictLoadedHandler, site, verdictMissingHandler, _AVAILABLE_VERDICT_METHODS, _FIELDS_EXPAND_TABLE;

site = require('./site.js');

config = require('./config.js');

MANDATORY_BASE_FIELDS = ['id', 'site'];

AVAILABLE_VERDICT_FIELDS = ['price', 'discount', 'instore', 'review', 'benefits'];

AVAILABLE_COMPARES = ['above', 'under', 'equal', 'match'];

_AVAILABLE_VERDICT_METHODS = AVAILABLE_VERDICT_FIELDS.map(function(field) {
  return 'verdict' + field.slice(0, 1).toUpperCase() + field.substring(1);
});

_FIELDS_EXPAND_TABLE = {
  url: site.generateProductUrl,
  encoding: function(i, s) {
    return site.getSiteEncoding(s);
  }
};

MANDATORY_EXPAND_FIELDS = [];

for (field in _FIELDS_EXPAND_TABLE) {
  expand = _FIELDS_EXPAND_TABLE[field];
  MANDATORY_EXPAND_FIELDS.push(field);
}

illegalTypeHandler = function(id, site, field) {
  logger.error('id %s site %s %s verdict with a illegal value', id, site, field);
  throw new Error('value not support error, illegal verdict value');
};

verdictMissingHandler = function(id, site) {
  logger.error('id %s site %s missing verdict field', id, site);
  throw new Error('value missing error, non verdict fields specified');
};

noneVerdictLoadedHandler = function(id, site) {
  logger.error('id %s site %s none verdict loaded', id, site);
  throw new Error('load error, none verdict fields loaded');
};

Seed = (function() {
  function Seed(verdict) {
    var regex, self;
    self = this;
    MANDATORY_BASE_FIELDS.map(function(field) {
      return self[field] = verdict[field];
    });
    for (field in _FIELDS_EXPAND_TABLE) {
      expand = _FIELDS_EXPAND_TABLE[field];
      this[field] = expand.apply(null, MANDATORY_BASE_FIELDS.map(function(field) {
        return verdict[field];
      }));
    }
    (function() {
      var verdictLoaded;
      verdictLoaded = false;
      AVAILABLE_VERDICT_FIELDS.map(function(field) {
        if (verdict[field]) {
          if (verdict[field].target !== 'null') {
            self[field] = verdict[field];
            verdictLoaded = true;
          } else {
            illegalTypeHandler(verdict.id, verdict.site, field);
          }
        }
      });
      !verdictLoaded && verdictMissingHandler(verdict.id, verdict.site);
    })();
    if (verdict.price) {
      this.verdictPrice = function(x) {
        return x.price < verdict.price.target;
      };
    }
    if (verdict.discount) {
      this.verdictDiscount = function(x) {
        return verdict.discount.target < x.discount;
      };
    }
    if (verdict.review) {
      this.verdictReview = function(x) {
        return verdict.review.target < x.review;
      };
    }
    if (verdict.instore) {
      this.verdictInstore = function(x) {
        return x.instore === verdict.instore;
      };
    }
    if (verdict.benefits) {
      regex = new RegExp(verdict.benefits.regex, verdict.benefits.option);
      this.verdictBenefits = function(x) {
        return x.benefits.some(function(elt) {
          return regex.test(elt);
        });
      };
    }
    _AVAILABLE_VERDICT_METHODS.some(function(verdict) {
      return self[verdict];
    }) || noneVerdictLoadedHandler(verdict.id, verdict.site);
    return;
  }

  Seed.prototype.verdict = function(result) {
    var self;
    self = this;
    return _AVAILABLE_VERDICT_METHODS.filter(function(method) {
      return self[method];
    }).every(function(method) {
      return self[method](result);
    });
  };

  Seed.prototype.equal = function(seed) {
    var self;
    self = this;
    return MANDATORY_BASE_FIELDS.every(function(field) {
      return self[field] === seed[field];
    });
  };

  return Seed;

})();

exports.Seed = Seed;

exports.MANDATORY_BASE_FIELDS = MANDATORY_BASE_FIELDS;

exports.MANDATORY_EXPAND_FIELDS = MANDATORY_EXPAND_FIELDS;

exports.AVAILABLE_VERDICT_FIELDS = AVAILABLE_VERDICT_FIELDS;

exports.AVAILABLE_COMPARES = AVAILABLE_COMPARES;

module.exports = exports;
