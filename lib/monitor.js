// Generated by CoffeeScript 1.8.0
var MANDATORY_BASE_FIELDS, Monitor, Seed, async, config, createVisitor, db, fs, path, productFile, request, s, shortenToken, util;

util = require('util');

fs = require('fs');

path = require('path');

async = require('async');

request = require('request');

config = require('./config.js');

createVisitor = require('./visitor.js').createVisitor;

s = require('./seed.js');

Seed = s.Seed;

MANDATORY_BASE_FIELDS = s.MANDATORY_BASE_FIELDS;

db = require('./db.js');

productFile = '../product.json';

shortenToken = function(token) {
  return token.slice(0, 7);
};

Monitor = (function() {
  function Monitor() {
    var self, verdicts;
    self = this;
    this.client = db.getClient();
    if (0 < config.accounts.length) {
      this.accessTokens = config.accounts.map(function(account) {
        return account.accessToken;
      });
    } else {
      throw new Error('access token empty');
    }
    verdicts = JSON.parse(fs.readFileSync(path.join(__dirname, productFile)));
    if (0 < verdicts.length) {
      this.seeds = verdicts.map(function(item) {
        return new Seed(item);
      });
    } else {
      throw new Error('products empty');
    }
    logger.debug('load seeds ok.');
  }

  Monitor.prototype.verifyUserTokens = function(callback) {
    var makeVerifyDone, problemTokens, self, verifyDone;
    self = this;
    problemTokens = [];
    logger.info('user access tokens verifying ...');
    makeVerifyDone = function() {
      var counter;
      counter = self.accessTokens.length;
      return function() {
        counter -= 1;
        if (counter <= 0) {
          logger.info('all access tokens verify done.');
          self.accessTokens = self.accessTokens.filter(function(token) {
            return problemTokens.indexOf(token) === -1;
          });
          if (self.accessTokens.length !== 0) {
            callback();
          } else {
            throw new Error('all access token is invalid');
          }
        }
      };
    };
    verifyDone = makeVerifyDone();
    this.accessTokens.map(function(token) {
      var options, shortToken;
      shortToken = shortenToken(token);
      options = {
        url: config.userServiceUrl,
        auth: {
          user: token
        }
      };
      request.get(options, function(err, res, body) {
        if (!err && res.statusCode === 200) {
          logger.debug('token %s verify ok', shortToken);
        } else if (err) {
          logger.error('token %s verify caught request error.', shortToken);
          logger.error('%s %s', shortToken, err.message);
          problemTokens.push(token);
          logger.info('%s removed from subscribers', shortToken);
        } else if (res.statusCode === 401) {
          logger.warn('token %s is invalid', shortToken);
          logger.warn('%s status code: %s', shortToken, res.statusCode);
          logger.warn('%s message: %s', shortToken, body);
          problemTokens.push(token);
          logger.info('%s removed from subscribers', shortToken);
        } else {
          logger.warn('token %s is invalid', shortToken);
          logger.warn('%s status code: %s', shortToken, res.statusCode);
          logger.warn('%s message: %s', shortToken, body);
          problemTokens.push(token);
          logger.info('%s removed from subscribers', shortToken);
        }
        verifyDone();
      });
    });
  };

  Monitor.prototype.delaySeed = function(id, site) {
    var previousSeeds, self;
    self = this;
    previousSeeds = self.seeds;
    self.seeds = previousSeeds.filter(function(s) {
      return s.id !== id || s.site !== site;
    });
    previousSeeds.filter(function(s) {
      return s.id === id && s.site === site;
    }).forEach(function(s) {
      var debugMsg;
      debugMsg = 'product ';
      MANDATORY_BASE_FIELDS.map(function(field) {
        debugMsg += util.format('%s %s', field, s[field]);
      });
      debugMsg += ' delayed';
      logger.info(debugMsg);
      setTimeout((function() {
        self.seeds.push(s);
      }), config.resendDelay);
    });
  };

  Monitor.prototype.sendRequests = function() {
    if (0 < this.seeds.length) {
      this.seeds.map(function(seed) {
        createVisitor(seed).visit();
      });
    }
  };

  Monitor.prototype.startMonitorInterval = function() {
    var self;
    self = this;
    setInterval((function() {
      var iter;
      iter = function() {
        self.client.rpop(config.redisPushQueueKey, function(err, res) {
          var item;
          if (!err) {
            if (res) {
              item = JSON.parse(res);
              self.delaySeed(item.id, item.site);
              iter();
            } else {
              logger.debug('delay push queue done');
              self.sendRequests();
            }
          } else {
            logger.error('rpop push queue caught error');
            logger.error('message: %s', err.message);
            throw err;
          }
        });
      };
      iter();
    }), config.monitorInterval);
  };

  Monitor.prototype.start = function() {
    this.verifyUserTokens(this.startMonitorInterval);
  };

  return Monitor;

})();

module.exports.createMonitor = function() {
  return new Monitor();
};
